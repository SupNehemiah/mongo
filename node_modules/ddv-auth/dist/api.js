/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define([], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory();
	}
}(this, function () {

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {
	    /*
	     * Local polyfil of Object.create
	     */
	    var create = Object.create || (function () {
	        function F() {};

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            var r = (function (m_w) {
	                var m_w = m_w;
	                var m_z = 0x3ade68b1;
	                var mask = 0xffffffff;

	                return function () {
	                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
	                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
	                    var result = ((m_z << 0x10) + m_w) & mask;
	                    result /= 0x100000000;
	                    result += 0.5;
	                    return result * (Math.random() > .5 ? 1 : -1);
	                }
	            });

	            for (var i = 0, rcache; i < nBytes; i += 4) {
	                var _r = r((rcache || Math.random()) * 0x100000000);

	                rcache = _r() * 0x3ade67b7;
	                words.push((_r() * 0x100000000) | 0);
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                var processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// 导出模块
module.exports = util;

// 创建最后总和
var createNewidSumLast = 0;
// 创建最后时间
var createNewidTimeLast = 0;
// 创建请求id
Object.assign(util, {
  /**
   * 创建一个当前运行环境中唯一的id
   * @param    {Boolean}                 is10 [是否为10进制]
   * @return   {String}                       [返回唯一id]
   */
  createNewPid: function createNewid(is10) {
    var r;
    if (createNewidTimeLast !== util.time()) {
      createNewidTimeLast = util.time();
      createNewidSumLast = 0;
    }
    r = createNewidTimeLast.toString() + (++createNewidSumLast).toString();
    // 使用36进制
    if (!is10) {
      r = parseInt(r, 10).toString(36);
    }
    return r;
  },
  /**
   * 生成guid
   * @param    {String}                 s [模板]
   * @return   {String}                   [返回guid]
   */
  createGuid: function createGuid(s) {
    return (s || 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx').replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0;
      var v = c === 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  }
});

// 时间工具
Object.assign(util, {
  /**
   * 获取当前时间开始
   * @return   {Int}                 [毫秒级时间戳]
   */
  now: function now() {
    return new Date().getTime();
  },
  /**
   * 获取php的时间戳
   * @return   {Int}                 [秒级时间戳]
   */
  time: function time() {
    return parseInt(util.now() / 1000);
  },
  /**
   * 去空格
   * @param    {String}                 t [需要去空格的字符串]
   * @return   {String}                   [去空格后的字符串]
   */
  trim: function trim(t) {
    return t || typeof t === 'string' ? t.toString().trim() : t;
  }
});

// 基本判断
Object.assign(util, {
  /**
   * 判断是一个方法
   * @param    {Function}               fn [这个对象是否一个方法]
   * @return   {Boolean}                   [是否为一个方法]
   */
  isFunction: function isFunction(fn) {
    return typeof fn === 'function';
  },
  /**
   * 判断是否为一个数组
   * @param    {Array}               fn [这个对象是否一个方法]
   * @return   {Boolean}                [description]
   */
  isArray: function isArray(a) {
    return Array.isArray.apply(this, arguments);
  },
  /**
   * 是否为一个数字
   * @author: 桦 <yuchonghua@163.com>
   * @DateTime 2017-07-28T09:46:39+0800
   * @param    {[type]}                 obj [description]
   * @return   {Boolean}                    [description]
   */
  isNumber: function isNumber(obj) {
    return (typeof obj === 'string' || typeof obj === 'number') && !util.isArray(obj) && obj - parseFloat(obj) >= 0;
  },
  // 判断是否一个标准的global
  isGlobal: function isGlobal(obj) {
    return obj !== void 0 && obj === obj.global;
  },
  // 类似php里面的inArray
  inArray: function inArray(a, b) {
    if (!util.isArray(b)) {
      return false;
    }
    for (var i in b) {
      if (b[i] === a) {
        return true;
      }
    }
    return false;
  }
});

// 基本工具
Object.assign(util, {
  // 克隆
  clone: function clone(myObj) {
    var i, myNewObj;
    if (!(myObj && (typeof myObj === 'undefined' ? 'undefined' : _typeof(myObj)) === 'object')) {
      return myObj;
    }
    if (myObj === null || myObj === undefined) {
      return myObj;
    }
    myNewObj = '';
    if (util.isArray(myObj)) {
      myNewObj = [];
      for (i = 0; i < myObj.length; i++) {
        myNewObj.push(myObj[i]);
      }
    } else if ((typeof myObj === 'undefined' ? 'undefined' : _typeof(myObj)) === 'object') {
      myNewObj = {};
      if (myObj.constructor && myObj.constructor !== Object) {
        myNewObj = myObj;
        // 防止克隆ie下克隆  Element 出问题
      } else if (myObj.innerHTML !== undefined && myObj.innerText !== undefined && myObj.tagName !== undefined && myObj.tabIndex !== undefined) {
        myNewObj = myObj;
      } else {
        for (i in myObj) {
          myNewObj[i] = clone(myObj[i]);
        }
      }
    }
    return myNewObj;
  },
  /**
   * 复制对象，通过制定key
   * @author: 桦 <yuchonghua@163.com>
   * @DateTime 2017-07-28T09:47:56+0800
   * @param    {[type]}                 oldObj [description]
   * @param    {[type]}                 newObj [description]
   * @param    {[type]}                 keys   [description]
   * @return   {[type]}                        [description]
   */
  copyObjByKey: function copyObjByKey(oldObj, newObj, keys) {
    keys = keys || [];
    keys.forEach(function (key) {
      oldObj[key] = newObj[key] || oldObj[key];
    });
  },
  // 设置错误id
  setErrorId: function setErrorId(errorId, error) {
    error.errorId = errorId;
    error.error_id = errorId;
    return error;
  },
  // 参数强转数组
  argsToArray: function argsToArray(args) {
    return Array.prototype.slice.call(args);
  }
});

// nextTick
Object.assign(util, {
  nextTick: __webpack_require__(5)
});
// 类型
var class2type = function () {
  var t = {};
  // Populate the class2type map
  'Boolean Number String Function Array Date RegExp Object Error'.split(' ').forEach(function (name) {
    t['[object ' + name + ']'] = name.toLowerCase();
  });
  return t;
}();

Object.assign(util, {
  type: function type(obj, isType) {
    if (isType !== void 0) {
      return isType === util.type(obj);
    }
    if (obj === void 0) {
      return obj + '';
    }
    // Support: Android<4.0, iOS<6 (functionish RegExp)
    return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' || typeof obj === 'function' ? class2type[class2type.toString.call(obj)] || 'object' : typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
  },
  isPlainObject: function isPlainObject(obj) {
    // Not plain objects:
    // - Any object or value whose internal [[Class]] property is not "[object Object]"
    // - DOM nodes
    // - window
    if (util.type(obj) !== 'object' || obj.nodeType || util.isGlobal(obj)) {
      return false;
    }

    if (obj.constructor && !Object.hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf')) {
      return false;
    }

    // If the function hasn't returned already, we're confident that
    // |obj| is a plain object, created by {} or constructed with new Object
    return true;
  },
  extend: function extend() {
    var options, name, src, copy, copyIsArray, clone;
    var target = arguments[0] || {};
    var i = 1;
    var length = arguments.length;
    var deep = false;
    // Handle a deep copy situation
    if (typeof target === 'boolean') {
      deep = target;

      // Skip the boolean and the target
      target = arguments[i] || {};
      i++;
    }

    // Handle case when target is a string or something (possible in deep copy)
    if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) !== 'object' && !util.isFunction(target)) {
      target = {};
    }

    // Extend jQuery itself if only one argument is passed
    if (i === length) {
      target = this;
      i--;
    }

    for (; i < length; i++) {
      // Only deal with non-null/undefined values
      if ((options = arguments[i]) !== void 0) {
        // Extend the base object
        for (name in options) {
          src = target[name];
          copy = options[name];

          // Prevent never-ending loop
          if (target === copy) {
            continue;
          }

          // Recurse if we're merging plain objects or arrays
          if (deep && copy && (util.isPlainObject(copy) || (copyIsArray = util.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && util.isArray(src) ? src : [];
            } else {
              clone = src && util.isPlainObject(src) ? src : Object.create(null);
            }

            // Never move original objects, clone them
            target[name] = util.extend(deep, clone, copy);

            // Don't bring in undefined values
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }

    // Return the modified object
    return target;
  }
});

function util() {}

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var util = __webpack_require__(1);
var url = __webpack_require__(9);
var parseStrByPhp = __webpack_require__(6);
// 工具
module.exports = url;
Object.assign(url, {
  parse: function parse(uri) {
    var r = {
      scheme: 'http',
      host: null,
      port: null,
      user: null,
      pass: null,
      path: '/',
      query: '',
      fragment: ''
    };
    if (uri && uri.indexOf && uri.charAt && uri.indexOf(':') === -1 && uri.charAt(0) !== '/') {
      uri = '/' + uri;
    }
    var t = url('{}', uri || '/');
    r.scheme = t.protocol ? t.protocol : r.scheme;
    r.host = t.hostname ? t.hostname : r.host;
    r.port = t.port ? t.port : r.port;
    r.user = t.user ? t.user : r.user;
    r.pass = t.pass ? t.pass : r.pass;
    r.path = t.path ? t.path : r.path;
    r.query = t.query ? t.query : r.query;
    r.fragment = t.hash ? t.hash : r.fragment;
    return r;
  },
  parseQuery: function parseQuery(query) {
    query = query || '';
    var r = {};
    parseStrByPhp(query, r);
    return r;
  },
  buildQuery: function buildQuery(params, isQuery) {
    params = params || {};
    var r = url._buildParamsToArray(params, '').join('&');
    if (isQuery) {
      r = r.replace(/%20/gi, '+');
    }
    return r;
  }
});

// urlEncode 编码
Object.assign(url, {
  // 编码对照数组表
  kEscapedMap: {
    '!': '%21',
    '\'': '%27',
    '(': '%28',
    ')': '%29',
    '*': '%2A'
  },
  // 编码
  urlDecode: function urlDecode(string) {
    return decodeURIComponent(string);
  },
  // 编码
  urlEncode: function urlEncode(string, encodingSlash) {
    var result = encodeURIComponent(string);
    result = result.replace(/[!'()*]/g, function (key) {
      return url.kEscapedMap[key];
    });
    if (encodingSlash === false) {
      result = result.replace(/%2F/gi, '/');
    }
    return result;
  },
  // path编码
  urlEncodeExceptSlash: function urlEncodeExceptSlash(value) {
    return url.urlEncode(value, false);
  }
});

// 对象序列化
Object.assign(url, {
  _buildParamsToArray: function _buildParamsToArray(data, prefix) {
    var r = [];
    var i, key, keyt, value;
    if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
      // 数组
      if (util.isArray(data)) {
        for (i = 0; i < data.length; i++) {
          // 值
          value = data[i];
          if (value === void 0) continue;
          // 键
          keyt = url._buildParamsAddPrefix(i, prefix, (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object');
          // 递归处理对象和数组
          if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
            // 插入数组
            r.push.apply(r, url._buildParamsToArray(value, keyt));
          } else {
            // 插入数组
            r.push(url.urlEncode(keyt) + '=' + url.urlEncode(value));
          }
        }
      } else {
        for (key in data) {
          if (!Object.hasOwnProperty.call(data, key)) {
            continue;
          }
          // 值
          value = data[key];
          if (value === void 0) continue;
          // 键
          keyt = url._buildParamsAddPrefix(key, prefix);
          if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
            // 插入数组
            r.push.apply(r, url._buildParamsToArray(value, keyt));
          } else {
            // 插入数组
            r.push(url.urlEncode(keyt) + '=' + url.urlEncode(value));
          }
        }
      }
    }
    return r;
  },
  _buildParamsAddPrefix: function _buildParamsAddPrefix(key, prefix, isNotArray) {
    if (prefix) {
      return prefix + '[' + (isNotArray !== false ? key : '') + ']';
    } else {
      return key;
    }
  }
});
Object.assign(url, {
  /**
   * Build a URL.
   *
   * The parts of the second URL will be merged into the first according to
   * the flags argument.
   *
   * @param mixed urli     (part(s) of) an URL in form of a string or
   *                       associative array like parse_url() returns
   * @param mixed parts   same as the first argument
   * @param int   flags   a bitmask of binary or'ed HTTP_URL constants;
   *                       HTTP_URL_REPLACE is the default
   * @param array new_url if set, it will be filled with the parts of the
   *                       composed url like parse_url() would return
   * @return string
   */
  build: function build(urli, parts, flags) {
    urli = urli || {};
    parts = parts || {};
    flags = flags || url.HTTP_URL_REPLACE;
    (typeof urli === 'undefined' ? 'undefined' : _typeof(urli)) === 'object' || (urli = url.parse(urli));
    (typeof parts === 'undefined' ? 'undefined' : _typeof(parts)) === 'object' || (parts = url.parse(parts));

    var keys = ['user', 'pass', 'port', 'path', 'query', 'fragment'];

    // HTTP_URL_STRIP_ALL and HTTP_URL_STRIP_AUTH cover several other flags.
    if (flags & url.HTTP_URL_STRIP_ALL) {
      flags |= url.HTTP_URL_STRIP_USER | url.HTTP_URL_STRIP_PASS | url.HTTP_URL_STRIP_PORT | url.HTTP_URL_STRIP_PATH | url.HTTP_URL_STRIP_QUERY | url.HTTP_URL_STRIP_FRAGMENT;
    } else if (flags & url.HTTP_URL_STRIP_AUTH) {
      flags |= url.HTTP_URL_STRIP_USER | url.HTTP_URL_STRIP_PASS;
    }

    // Schema and host are alwasy replaced
    var t = ['scheme', 'host'];
    var i;
    for (i = 0; i < t.length; i++) {
      if (parts && t[i] && parts[t[i]]) {
        urli[t[i]] = parts[t[i]];
      }
    }

    if (flags & url.HTTP_URL_REPLACE) {
      for (i = 0; i < keys.length; i++) {
        if (parts && keys[i] && parts[keys[i]]) {
          urli[keys[i]] = parts[keys[i]];
        }
      }
    } else {
      if (parts && parts['path'] && flags & url.HTTP_URL_JOIN_PATH) {
        if (urli && urli['path'] && parts['path'].substr(0, 1) !== '/') {
          var leftTemp, rigthTemp;
          // Workaround for trailing slashes
          leftTemp = rigthTemp = '';
          if (parts['path']) {
            parts['path'] = (parts['path'] || '').toString();
            i = parts['path'].indexOf('/');
            if (i > -1) {
              rigthTemp = parts['path'].substr(i + 1);
            }
          }
          if (urli['path']) {
            urli['path'] = (urli['path'] || '').toString();
            i = urli['path'].lastIndexOf('/');
            if (i > -1) {
              leftTemp = urli['path'].substr(0, i);
            }
          }
          urli['path'] = rigthTemp ? leftTemp : leftTemp + '/' + rigthTemp;
        } else {
          urli['path'] = parts['path'];
        }
      }

      if (parts && parts['query'] && flags & url.HTTP_URL_JOIN_QUERY) {
        if (urli && urli['query']) {
          var urliQuery = url.parseQuery(urli['query']);
          var partsQuery = url.parseQuery(parts['query']);
          urli['query'] = url.buildQuery(util.extend({}, urliQuery, partsQuery));
        } else {
          urli['query'] = parts['query'];
        }
      }
    }

    if (urli && urli['path'] && urli['path'] !== '' && (urli['path'] || '').substr(0, 1) !== '/') {
      urli['path'] = '/'.urli['path'];
    }

    var strip;
    for (i = 0; i < keys.length; i++) {
      strip = 'HTTP_URL_STRIP_' + (keys[i] || '').toUpperCase();
      if (flags & url[strip]) {
        delete urli[keys[i] || ''];
      }
    }

    var parsedString = '';

    if (urli['scheme']) {
      parsedString += urli['scheme'] + '://';
    }

    if (urli['user']) {
      parsedString += urli['user'];

      if (urli['pass']) {
        parsedString += ':' + urli['pass'];
      }

      parsedString += '@';
    }

    if (urli['host']) {
      parsedString += urli['host'];
    }

    if (urli['port']) {
      parsedString += ':' + urli['port'];
    }

    if (urli['path']) {
      parsedString += urli['path'];
    }

    if (urli['query']) {
      parsedString += '?' + urli['query'];
    }

    if (urli['fragment']) {
      parsedString += '#' + urli['fragment'];
    }

    return parsedString;
  }
});

Object.assign(url, {
  'HTTP_URL_REPLACE': 1,
  'HTTP_URL_JOIN_PATH': 2,
  'HTTP_URL_JOIN_QUERY': 4,
  'HTTP_URL_STRIP_USER': 8,
  'HTTP_URL_STRIP_PASS': 16,
  'HTTP_URL_STRIP_AUTH': 32,
  'HTTP_URL_STRIP_PORT': 64,
  'HTTP_URL_STRIP_PATH': 128,
  'HTTP_URL_STRIP_QUERY': 256,
  'HTTP_URL_STRIP_FRAGMENT': 512,
  'HTTP_URL_STRIP_ALL': 1024
});

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = AuthSha256;
var util = __webpack_require__(1);
var url = __webpack_require__(2);
var time = __webpack_require__(8);
var sign = __webpack_require__(7);
var AuthSha256Prototype = {};
var urlKeys = 'scheme host user pass  port path query fragment'.split(' ');

function AuthSha256(uri, method, authVersion, path, query, noSignQueryKeys, headers, noSignHeadersKeys) {
  if (this instanceof AuthSha256) {
    var agrs = util.argsToArray(arguments);
    return this.construct.apply(this, agrs);
  } else {
    return new AuthSha256(uri, method, authVersion, path, query, noSignQueryKeys, headers, noSignHeadersKeys);
  }
}
// 继承
AuthSha256.prototype = AuthSha256Prototype;
Object.assign(AuthSha256Prototype, {
  baseInit: function baseInit() {
    this.authVersion = 'ddv-auth-v1';
    this.accessKeyId = '';
    this.accessKey = '';
    this.requestId = '';
    this.deviceCard = '';
    this.signTimeString = '';
    this.expiredTimeOffset = 1800;
    this.method = 'GET';
    this.scheme = 'http';
    this.uri = '';
    this.user = '';
    this.pass = '';
    this.host = '';
    this.fragment = '';
    this.query = {};
    this.noSignQueryKeys = [];
    this.headers = {};
    this.noSignHeadersKeys = [];
  },
  construct: function construct(uri, method, authVersion, path, query, noSignQueryKeys, headers, noSignHeadersKeys) {
    this.baseInit();
    this.setMethod(method || 'GET');
    this.setUri(uri || null);
    this.setPath(path || null);
    this.setQuery(query || {});
    this.setNoSignQueryKeys(noSignQueryKeys || []);
    this.setHeaders(headers || {});
    this.setNoSignHeadersKeys(noSignHeadersKeys || []);
    this.setAuthVersion(authVersion || 'ddv-auth-v1');
  },
  /**
   * 获取uri
   * @return {String} uri [请求对象]
   */
  getUri: function getUri() {
    var i, key;
    var t = {};
    for (i = 0; i < urlKeys.length; i++) {
      key = urlKeys[i];
      if (key && this[key]) {
        t[key] = this[key];
      }
    }
    if (t.query) {
      // 编译get请求的参数
      t.query = url.buildQuery(t.query, true);
    }
    key = void 0;
    // 编译生成url
    this.uri = url.build(t);
    return this.uri;
  },
  /**
   * 设置uri
   * @param  {String}      uri [请求uri]
   * @return {AuthSha256} this [请求对象]
   */
  setUri: function setUri(uri) {
    var uriObj;
    uri = uri || '';
    // 解析uri
    uriObj = url.parse(uri);
    if (typeof uriObj['scheme'] !== 'undefined' && uriObj['scheme']) {
      this.setScheme(uriObj['scheme']);
    }
    if (typeof uriObj['host'] !== 'undefined' && uriObj['host']) {
      this.setHost(uriObj['host']);
    }
    if (typeof uriObj['user'] !== 'undefined' && uriObj['user']) {
      this.setHost(uriObj['user']);
    }
    if (typeof uriObj['pass'] !== 'undefined' && uriObj['pass']) {
      this.setHost(uriObj['pass']);
    }
    if (typeof uriObj['path'] !== 'undefined' && uriObj['path']) {
      this.setPath(uriObj['path']);
    }
    if (typeof uriObj['query'] !== 'undefined' && uriObj['query']) {
      this.setQuery(uriObj['query']);
    }
    if (typeof uriObj['fragment'] !== 'undefined' && uriObj['fragment']) {
      this.setFragment(uriObj['fragment']);
    }
    return this;
  },
  /**
   * 设置fragment
   * @param  {String} fragment [description]
   * @return {AuthSha256} this [请求对象]
   */
  setFragment: function setFragment(fragment) {
    this.fragment = typeof fragment === 'undefined' || !fragment ? '' : fragment;
    return this;
  },
  /**
   * 设置path
   * @param  {String} path [相对跟路径]
   * @return {AuthSha256} this [请求对象]
   */
  setPath: function setPath(path) {
    // 解析uri
    var uriObj = url.parse(path);
    this.path = uriObj['path'] || this.path || '/';
    this.path = (this.path.charAt(0) === '/' ? '' : '/') + this.path;
    if (uriObj['query']) {
      this.setQuery(url.parseQuery(uriObj['query']));
    }
    return this;
  },
  setHost: function setHost(host) {
    this.host = typeof host === 'undefined' || !host ? '' : host;
    return this;
  },
  setScheme: function setScheme(scheme) {
    this.scheme = typeof scheme === 'undefined' || !scheme ? '' : scheme;
    return this;
  },
  /**
   * 设置请求参数
   * @param  {Array}  query   [请求参数]
   * @param  {Boolean} isClean [是否清除原有的]
   * @return {AuthSha256} this [请求对象]
   */
  setQuery: function setQuery(query, isClean) {
    isClean = isClean || false;

    if (typeof query !== 'undefined' && query && typeof query === 'string') {
      query = url.parseQuery(query);
    }
    if (isClean !== false) {
      this.query = [];
    }
    this.query = util.extend(this.query, util.clone(query));
    return this;
  },
  /**
   * 设置忽略签名的请求参数的key数组
   * @param  {Array}  query   [请求参数]
   * @param  {Noolean} isClean [是否清除原有的]
   * @return {AuthSha256} this [请求对象]
   */
  setNoSignQueryKeys: function setNoSignQueryKeys(noSignQueryKeys, isClean) {
    isClean = isClean || false;

    if (isClean !== false) {
      this.noSignQueryKeys = [];
    }

    if (typeof noSignQueryKeys === 'string') {
      this.noSignQueryKeys.push(noSignQueryKeys);
    } else if (Array.isArray(noSignQueryKeys)) {
      for (var i = 0, len = noSignQueryKeys.length; i < len; i++) {
        this.noSignQueryKeys.push(noSignQueryKeys[i]);
      }
    }

    return this;
  },
  /**
   * 设置请求头的数组
   * @param  {Array}  headers   [请求头]
   * @param  {Boolean} isClean [是否清除原有的]
   * @return {AuthSha256} this [请求对象]
   */
  setHeaders: function setHeaders(headers, isClean) {
    if (typeof headers === 'string' && typeof isClean !== 'undefined') {
      var headersTemp = {};
      headersTemp[headers] = isClean;
      return this.setHeaders(headersTemp);
    }
    isClean = isClean || false;

    if (isClean !== false) {
      this.headers = {};
    }

    if ((typeof headers === 'undefined' ? 'undefined' : _typeof(headers)) === 'object') {
      var keys = Object.keys(headers);
      var len = keys.length;
      for (var i = 0; i < len; i++) {
        this.headers[keys[i]] = Array.isArray(headers[keys[i]]) ? headers[keys[i]].join('; ') : headers[keys[i]];
      }
    }

    return this;
  },
  /**
   * 设置忽略签名的请求头的key数组
   * @param  {Array}  headers   [请求头key]
   * @param  {Boolean} isClean [是否清除原有的]
   * @return {AuthSha256} this [请求对象]
   */
  setNoSignHeadersKeys: function setNoSignHeadersKeys(noSignHeadersKeys, isClean) {
    isClean = isClean || false;

    if (isClean !== false) {
      this.noSignHeadersKeys = [];
    }

    if (typeof noSignHeadersKeys === 'string') {
      this.noSignHeadersKeys.push(noSignHeadersKeys.toLocaleLowerCase());
    } else if (Array.isArray(noSignHeadersKeys)) {
      for (var i = 0, len = noSignHeadersKeys.length; i < len; i++) {
        noSignHeadersKeys[i] = typeof noSignHeadersKeys[i] === 'string' || typeof noSignHeadersKeys[i] === 'number' ? noSignHeadersKeys[i].toString() : '';
        this.noSignHeadersKeys.push(noSignHeadersKeys[i].toLocaleLowerCase());
      }
    }

    return this;
  },
  setAuthVersion: function setAuthVersion(authVersion) {
    this.authVersion = authVersion;
    return this;
  },
  /**
   * 授权id
   * @param  {String} accessKeyId [授权id]
   * @return {AuthSha256} this [请求对象]
   */
  setAccessKeyId: function setAccessKeyId(accessKeyId) {
    this.accessKeyId = accessKeyId;
    return this;
  },
  /**
   * 授权key
   * @param  {String} accessKey [授权key]
   * @return {AuthSha256} this [请求对象]
   */
  setAccessKey: function setAccessKey(accessKey) {
    this.accessKey = accessKey;
    return this;
  },
  /**
   * 设置请求id
   * @param  {String} requestId [请求id]
   * @return {AuthSha256} this [请求对象]
   */
  setRequestId: function setRequestId(requestId) {
    this.requestId = requestId;
    return this;
  },
  /**
   * 设备cardid
   * @param  {String} deviceCard [设备cardid]
   * @return {AuthSha256} this [请求对象]
   */
  setDeviceCard: function setDeviceCard(deviceCard) {
    this.deviceCard = deviceCard;
    return this;
  },
  /**
   * 设置请求方式
   * @param  {String} method [请求方式]
   * @return {AuthSha256} this [请求对象]
   */
  setMethod: function setMethod(method) {
    this.method = method;
    return this;
  },
  /**
   * 设置过期时间偏移值
   * @param  {Int}                 expiredTimeOffset [description]
   * @return {AuthSha256} this [请求对象]
   */
  setExpiredTimeOffset: function setExpiredTimeOffset(expiredTimeOffset) {
    this.expiredTimeOffset = expiredTimeOffset;
    return this;
  },
  setSignTimeString: function setSignTimeString(signTimeString) {
    if (typeof signTimeString === 'number') {
      signTimeString = time.gmdate('Y-m-dTH:i:sZ', signTimeString);
    } else if (signTimeString instanceof Date) {
      signTimeString = time.gmdate('Y-m-dTH:i:sZ', parseInt(signTimeString.getTime() / 1000));
    }
    this.signTimeString = signTimeString;
    return this;
  },
  getSigningKey: function getSigningKey(authString) {
    if (authString) {
      authString = this.getAuthStringPrefix();
    }
    // 生成加密key
    var signingKey = sign.HmacSHA256(authString, this.accessKey);
    return signingKey;
  },
  getAuthStringPrefix: function getAuthStringPrefix() {
    // 授权字符串
    var authString = this.authVersion;
    if (this.requestId) {
      authString += '/' + this.requestId;
    }
    authString += '/' + this.accessKeyId;
    if (this.deviceCard) {
      authString += '/' + this.deviceCard;
    }
    authString += '/' + this.signTimeString + '/' + this.expiredTimeOffset;
    return authString;
  },
  getAuthString: function getAuthString() {
    var authObj = this.getAuthArray();
    return authObj['authString'];
  },
  checkSignTime: function checkSignTime() {
    // 签名时间
    var signTime = !this.signTimeString ? 0 : time.strtotime(this.signTimeString.toLocaleUpperCase());
    // 过期
    var expiredTimeOffset = !this.expiredTimeOffset ? 0 : parseInt(this.expiredTimeOffset);
    // 签名过期
    if (time.time() > signTime + expiredTimeOffset) {
      // 抛出过期
      throw new Error('Request authorization expired!', 'AUTHORIZATION_REQUEST_EXPIRED');
    } else if (signTime - expiredTimeOffset > time()) {
      // 签名期限还没有到
      throw new Error('Request authorization has not yet entered into force!', 'AUTHORIZATION_REQUEST_NOT_ENABLE');
    }
    return this;
  },
  getAuthArray: function getAuthArray() {
    // 获取auth
    var authString = this.getAuthStringPrefix();
    // 生成临时key
    var signingKey = this.getSigningKey(authString);
    // 获取path
    var canonicalPath = url.urlEncodeExceptSlash(this.path);
    var keys, i, len;

    var signQuery = {};
    keys = Object.keys(this.query);
    for (i = 0, len = keys.length; i < len; i++) {
      if (this.noSignQueryKeys.indexOf(keys[i]) <= -1) {
        signQuery[keys[i]] = this.query[keys[i]];
      }
    }

    // 重新排序编码
    var canonicalQuery = sign.canonicalQuerySort(url.buildQuery(signQuery));

    var signHeaders = {};
    keys = Object.keys(this.headers);
    for (i = 0, len = keys.length; i < len; i++) {
      keys[i] = typeof keys[i] === 'string' || typeof keys[i] === 'number' ? keys[i].toString() : '';
      if (this.noSignHeadersKeys.indexOf(keys[i].toLocaleLowerCase()) <= -1) {
        signHeaders[keys[i]] = this.headers[keys[i]];
      }
    }
    // 通过
    keys = Object.keys(signHeaders);
    var signHeaderKeysStr = keys.join(';');
    // 获取签名头
    var canonicalHeaders = sign.getCanonicalHeaders(signHeaders);
    // 生成需要签名的信息体
    var canonicalRequest = this.method + '\n' + canonicalPath + '\n' + canonicalQuery + '\n' + canonicalHeaders;

    // 服务端模拟客户端算出的签名信息
    var signMsg = sign.HmacSHA256(canonicalRequest, signingKey);
    // 组成最终签名串
    authString += '/' + signHeaderKeysStr + '/' + signMsg;

    return {
      'requestId.server': this.requestId,
      'accessKeyId.server': this.accessKeyId,
      'accessKey.server': this.accessKey,
      'deviceCard.server': this.deviceCard,
      'signingKey.server': signingKey,
      'signHeaderKeysStr.server': signHeaderKeysStr,
      'canonicalRequest.server': canonicalRequest,
      'sign': signMsg,
      'authString': authString
    };
  }
});

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 工具
module.exports = auth;
var util = __webpack_require__(1);
var AuthSha256 = __webpack_require__(3);
Object.assign(auth, {
  util: util,
  AuthSha256: AuthSha256
});
function auth() {}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

// 导出模块
module.exports = nextTick;
// 工具
var util = __webpack_require__(1);
// 下一进程队列
var nextTickQueue = [];
// 系统下一进程运行
var nextTickSys = function () {
  var fnc;
  if (typeof process !== 'undefined' && util.isFunction(process.nextTick)) {
    fnc = process.nextTick;
  } else {
    'r webkitR mozR msR oR'.split(' ').forEach(function (prefixes) {
      if (util.isFunction(fnc)) {
        return false;
      }
      fnc = window[prefixes + 'equestAnimationFrame'];
    });
    fnc = fnc && fnc.bind && fnc.bind(window) || window.setImmediate;
    if (!util.isFunction(fnc)) {
      if (typeof window === 'undefined' || window.ActiveXObject || !window.postMessage) {
        fnc = function fnc(f) {
          setTimeout(f, 0);
        };
      } else {
        window.addEventListener('message', function () {
          var i = 0;
          while (i < nextTickQueue.length) {
            try {
              nextTickQueue[i++]();
            } catch (e) {
              nextTickQueue.splice(0, i);
              window.postMessage('nextTick!', '*');
              throw e;
            }
          }
          nextTickQueue.length = 0;
        }, true);
        fnc = function fnc(fn) {
          if (!nextTickQueue.length) {
            window.postMessage('nextTick!', '*');
          }
          nextTickQueue.push(fn);
        };
      }
    }
  }
  return fnc;
}();
// 下一进程访问
function nextTick(fn) {
  var self = this;
  nextTickSys(function () {
    if (util.isFunction(fn)) {
      fn.call(self);
    }
    self = fn = void 0;
  });
  setTimeout(function () {
    if (util.isFunction(fn)) {
      fn.call(self);
    }
    self = fn = void 0;
  }, 0);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function parse_str(str, array) {
  // eslint-disable-line camelcase
  //       discuss at: http://locutus.io/php/parse_str/
  //      original by: Cagri Ekin
  //      improved by: Michael White (http://getsprink.com)
  //      improved by: Jack
  //      improved by: Brett Zamir (http://brett-zamir.me)
  //      bugfixed by: Onno Marsman (https://twitter.com/onnomarsman)
  //      bugfixed by: Brett Zamir (http://brett-zamir.me)
  //      bugfixed by: stag019
  //      bugfixed by: Brett Zamir (http://brett-zamir.me)
  //      bugfixed by: MIO_KODUKI (http://mio-koduki.blogspot.com/)
  // reimplemented by: stag019
  //         input by: Dreamer
  //         input by: Zaide (http://zaidesthings.com/)
  //         input by: David Pesta (http://davidpesta.com/)
  //         input by: jeicquest
  //           note 1: When no argument is specified, will put variables in global scope.
  //           note 1: When a particular argument has been passed, and the
  //           note 1: returned value is different parse_str of PHP.
  //           note 1: For example, a=b=c&d====c
  //        example 1: var $arr = {}
  //        example 1: parse_str('first=foo&second=bar', $arr)
  //        example 1: var $result = $arr
  //        returns 1: { first: 'foo', second: 'bar' }
  //        example 2: var $arr = {}
  //        example 2: parse_str('str_a=Jack+and+Jill+didn%27t+see+the+well.', $arr)
  //        example 2: var $result = $arr
  //        returns 2: { str_a: "Jack and Jill didn't see the well." }
  //        example 3: var $abc = {3:'a'}
  //        example 3: parse_str('a[b]["c"]=def&a[q]=t+5', $abc)
  //        example 3: var $result = $abc
  //        returns 3: {"3":"a","a":{"b":{"c":"def"},"q":"t 5"}}
  var strArr = String(str).replace(/^&/, '').replace(/&$/, '').split('&');
  var sal = strArr.length;
  var i;
  var j;
  var ct;
  var p;
  var lastObj;
  var obj;
  var undef;
  var chr;
  var tmp;
  var key;
  var value;
  var postLeftBracketPos;
  var keys;
  var keysLen;
  var _fixStr = function _fixStr(str) {
    return decodeURIComponent(str.replace(/\+/g, '%20'));
  };
  for (i = 0; i < sal; i++) {
    tmp = strArr[i].split('=');
    key = _fixStr(tmp[0]);
    value = tmp.length < 2 ? '' : _fixStr(tmp[1]);
    while (key.charAt(0) === ' ') {
      key = key.slice(1);
    }
    if (key.indexOf('\x00') > -1) {
      key = key.slice(0, key.indexOf('\x00'));
    }
    if (key && key.charAt(0) !== '[') {
      keys = [];
      postLeftBracketPos = 0;
      for (j = 0; j < key.length; j++) {
        if (key.charAt(j) === '[' && !postLeftBracketPos) {
          postLeftBracketPos = j + 1;
        } else if (key.charAt(j) === ']') {
          if (postLeftBracketPos) {
            if (!keys.length) {
              keys.push(key.slice(0, postLeftBracketPos - 1));
            }
            keys.push(key.substr(postLeftBracketPos, j - postLeftBracketPos));
            postLeftBracketPos = 0;
            if (key.charAt(j + 1) !== '[') {
              break;
            }
          }
        }
      }
      if (!keys.length) {
        keys = [key];
      }
      for (j = 0; j < keys[0].length; j++) {
        chr = keys[0].charAt(j);
        if (chr === ' ' || chr === '.' || chr === '[') {
          keys[0] = keys[0].substr(0, j) + '_' + keys[0].substr(j + 1);
        }
        if (chr === '[') {
          break;
        }
      }
      obj = array;
      for (j = 0, keysLen = keys.length; j < keysLen; j++) {
        key = keys[j].replace(/^['"]/, '').replace(/['"]$/, '');
        lastObj = obj;
        if (key !== '' && key !== ' ' || j === 0) {
          if (obj[key] === undef) {
            obj[key] = keys[keys.length - 1] === '' ? [] : {};
          }
          obj = obj[key];
        } else {
          // To insert new dimension
          ct = -1;
          for (p in obj) {
            if (obj.hasOwnProperty(p)) {
              if (+p > ct && p.match(/^\d+$/g)) {
                ct = +p;
              }
            }
          }
          key = ct + 1;
        }
      }
      lastObj[key] = value;
    }
  }
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var sign = {};
// 工具
var util = __webpack_require__(1);
var url = __webpack_require__(2);
var cryptoJsCore = __webpack_require__(0);
var cryptoJsHex = __webpack_require__(11);
var cryptoJsBase64 = __webpack_require__(10);
// var cryptoJsHmacSha256 =
__webpack_require__(12);
// var cryptoJsMd5 =
__webpack_require__(14);
module.exports = sign;
Object.assign(sign, {
  canonicalQuerySort: function canonicalQuerySort(canonicalQuery) {
    // 拆分get请求的参数
    if (!util.isArray(canonicalQuery) && (typeof canonicalQuery === 'undefined' ? 'undefined' : _typeof(canonicalQuery)) === 'object') {
      canonicalQuery = url.buildQuery(canonicalQuery, true);
    }
    if (typeof canonicalQuery === 'string') {
      canonicalQuery = canonicalQuery.split('&');
    }
    if (!util.isArray(canonicalQuery)) {
      canonicalQuery = (canonicalQuery || '').toString().split('&');
    }
    var i, len, temp, queryArray, tempIndex, key, value, r;
    len = canonicalQuery.length;
    queryArray = [];
    for (i = 0; i < len; i++) {
      temp = canonicalQuery[i];
      if (!temp) {
        continue;
      }
      tempIndex = temp.indexOf('=');
      if (tempIndex < 0) {
        continue;
      }
      // 取得key
      key = util.trim(temp.substr(0, tempIndex));
      // 取得value
      value = util.trim(temp.substr(tempIndex + 1));
      // 去空格
      // 插入新数组
      queryArray.push(url.urlEncode(url.urlDecode(key)) + '=' + url.urlEncode(url.urlDecode(value)));
    }
    // 排序
    queryArray.sort();
    // 用&拼接
    r = queryArray.join('&');
    // 回收内存
    i = len = temp = queryArray = tempIndex = key = value = void 0;

    return r;
  },
  getCanonicalHeaders: function getCanonicalHeaders(signHeaders) {
    var r, canonicalHeader, key, value;
    // 重新编码
    canonicalHeader = [];
    for (key in signHeaders) {
      value = signHeaders[key];
      canonicalHeader.push((url.urlEncode(util.trim(key)) || '').toLowerCase() + ':' + url.urlEncode(util.trim(util.isArray(value) ? value.join('; ') : value)));
    }
    canonicalHeader.sort();
    // 服务器模拟客户端生成的头
    r = canonicalHeader.join('\n');
    canonicalHeader = key = value = void 0;
    return r;
  },
  getHeaderKeysByStr: function getHeaderKeysByStr(signHeaderKeys) {
    var key, value, signHeaderKeysNew;
    if (typeof signHeaderKeys === 'string') {
      // 拆分头键名为数组 方便后期处理
      signHeaderKeys = signHeaderKeys.split(';');
    }
    if (!util.isArray(signHeaderKeys)) {
      signHeaderKeys = (signHeaderKeys || '').toString().split(';');
    }
    // 定义一个空数组来存储对授权头key预处理
    signHeaderKeysNew = [];
    // 遍历授权头的key
    for (key in signHeaderKeys) {
      value = util.trim(signHeaderKeys[key]);
      // 去空格
      util.inArray(value, signHeaderKeysNew) || signHeaderKeysNew.push(value);
    }
    // 把处理后的头的key覆盖原来的变量，释放内存
    signHeaderKeys = signHeaderKeysNew;
    // 移除数组中重复的值
    key = value = signHeaderKeys = void 0;
    return signHeaderKeysNew;
  },
  createGuid: function createGuid(opt) {
    return (opt ? '{' : '') + util.createGuid() + (opt ? '}' : '');
  },
  md5Hex: function md5Hex(str, isToString) {
    str = str || '';
    if (isToString !== false) {
      str = (str || '').toString();
    }
    return cryptoJsCore.MD5(str).toString(cryptoJsHex);
  },
  md5Base64: function md5Base64(str, isToString) {
    str = str || '';
    if (isToString !== false) {
      str = (str || '').toString();
    }
    return cryptoJsCore.MD5(str).toString(cryptoJsBase64);
  },
  /**
   * HmacSHA256
   * @param    {String}               str        [description]
   * @param    {String}               key        [description]
   * @param    {Boolean}              isToString [description]
   */
  HmacSHA256: function HmacSHA256(str, key, isToString) {
    str = str || '';
    if (isToString !== false) {
      str = (str || '').toString();
    }
    return cryptoJsCore.HmacSHA256(str, key).toString(cryptoJsHex);
  }
});

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = {};
module.exports = util;
Object.assign(util, {
  // 获取当前时间开始
  now: function now() {
    return new Date().getTime();
  },
  // 获取php的时间戳
  time: function time() {
    return parseInt(util.now() / 1000);
  },
  /**
   * [gmdate 和PHP一样的时间戳格式化函数 格式化后是格林时间]
   * @author: 桦 <yuchonghua@163.com>
   * @DateTime 2016-04-29T11:42:09+0800
   * @param    {string}              format    [格式格式时间]
   * @param    {int}                 timestamp [要格式化的时间 默认为当前时间]
   * @return   {string}                        [格式化的时间字符串]
   */
  gmdate: function gmdate(format, timestamp) {
    timestamp = timestamp === undefined ? util.time() : timestamp;
    timestamp = parseInt(timestamp) + 60 * new Date().getTimezoneOffset();
    return util.date(format, timestamp);
  },
  /**
   * [date 和PHP一样的时间戳格式化函数 格式化后是本地时间]
   * @author: 桦 <yuchonghua@163.com>
   * @DateTime 2016-04-29T11:42:09+0800
   * @param    {string}              format    [本地格式时间]
   * @param    {int}                 timestamp [要格式化的时间 默认为当前时间]
   * @return   {string}                        [格式化的时间字符串]
   */
  date: function date(format, timestamp) {
    var jsdate = timestamp ? new Date(timestamp * 1000) : new Date();
    var pad = function pad(n, c) {
      if ((n = n + '').length < c) {
        return new Array(++c - n.length).join('0') + n;
      } else {
        return n;
      }
    };
    var txtWeekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

    var txtOrdin = { 1: 'st', 2: 'nd', 3: 'rd', 21: 'st', 22: 'nd', 23: 'rd', 31: 'st' };

    var txtMonths = ['', 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

    var f = {
      // Day
      d: function d() {
        return pad(f.j(), 2);
      },
      D: function D() {
        var t = f.l();
        return t.substr(0, 3);
      },
      j: function j() {
        return jsdate.getDate();
      },
      l: function l() {
        return txtWeekdays[f.w()];
      },
      N: function N() {
        return f.w() + 1;
      },
      S: function S() {
        return txtOrdin[f.j()] ? txtOrdin[f.j()] : 'th';
      },
      w: function w() {
        return jsdate.getDay();
      },
      z: function z() {
        return (jsdate - new Date(jsdate.getFullYear() + '/1/1')) / 864e5 >> 0;
      },

      // Week
      W: function W() {
        var a = f.z();
        var b = 364 + f.L() - a;
        var nd2;
        var nd = (new Date(jsdate.getFullYear() + '/1/1').getDay() || 7) - 1;

        if (b <= 2 && (jsdate.getDay() || 7) - 1 <= 2 - b) {
          return 1;
        } else {
          if (a <= 2 && nd >= 4 && a >= 6 - nd) {
            nd2 = new Date(jsdate.getFullYear() - 1 + '/12/31');
            return util.date('W', Math.round(nd2.getTime() / 1000));
          } else {
            return 1 + (nd <= 3 ? (a + nd) / 7 : (a - (7 - nd)) / 7) >> 0;
          }
        }
      },

      // Month
      F: function F() {
        return txtMonths[f.n()];
      },
      m: function m() {
        return pad(f.n(), 2);
      },
      M: function M() {
        var t = f.F();
        return t.substr(0, 3);
      },
      n: function n() {
        return jsdate.getMonth() + 1;
      },
      t: function t() {
        var n;
        if ((n = jsdate.getMonth() + 1) === 2) {
          return 28 + f.L();
        } else {
          if (n & 1 && n < 8 || !(n & 1) && n > 7) {
            return 31;
          } else {
            return 30;
          }
        }
      },

      // Year
      L: function L() {
        var y = f.Y();
        return !(y & 3) && (y % 1e2 || !(y % 4e2)) ? 1 : 0;
      },
      // o not supported yet
      Y: function Y() {
        return jsdate.getFullYear();
      },
      y: function y() {
        return (jsdate.getFullYear() + '').slice(2);
      },

      // Time
      a: function a() {
        return jsdate.getHours() > 11 ? 'pm' : 'am';
      },
      A: function A() {
        return f.a().toUpperCase();
      },
      B: function B() {
        // peter paul koch:
        var off = (jsdate.getTimezoneOffset() + 60) * 60;
        var theSeconds = jsdate.getHours() * 3600 + jsdate.getMinutes() * 60 + jsdate.getSeconds() + off;
        var beat = Math.floor(theSeconds / 86.4);
        if (beat > 1000) beat -= 1000;
        if (beat < 0) beat += 1000;
        if (String(beat).length === 1) beat = '00' + beat;
        if (String(beat).length === 2) beat = '0' + beat;
        return beat;
      },
      g: function g() {
        return jsdate.getHours() % 12 || 12;
      },
      G: function G() {
        return jsdate.getHours();
      },
      h: function h() {
        return pad(f.g(), 2);
      },
      H: function H() {
        return pad(jsdate.getHours(), 2);
      },
      i: function i() {
        return pad(jsdate.getMinutes(), 2);
      },
      s: function s() {
        return pad(jsdate.getSeconds(), 2);
      },
      // u not supported yet

      // Timezone
      // e not supported yet
      // I not supported yet
      O: function O() {
        var t = pad(Math.abs(jsdate.getTimezoneOffset() / 60 * 100), 4);
        if (jsdate.getTimezoneOffset() > 0) t = '-' + t;else t = '+' + t;
        return t;
      },
      P: function P() {
        var O = f.O();
        return O.substr(0, 3) + ':' + O.substr(3, 2);
      },
      // T not supported yet
      // Z not supported yet

      // Full Date/Time
      c: function c() {
        return f.Y() + '-' + f.m() + '-' + f.d() + 'T' + f.h() + ':' + f.i() + ':' + f.s() + f.P();
      },
      // r not supported yet
      U: function U() {
        return Math.round(jsdate.getTime() / 1000);
      }
    };

    return format.replace(/[\\]?([a-zA-Z])/g, function (t, s) {
      var ret;
      if (t !== s) {
        // escaped
        ret = s;
      } else if (f[s]) {
        // a date function exists
        ret = f[s]();
      } else {
        // nothing special
        ret = s;
      }
      return ret;
    });
  },
  strtotime: function strtotime(text, now) {
    if (text && text instanceof Date) {
      return text.getTime() / 1000;
    }
    //  discuss at: http://locutus.io/php/strtotime/
    // original by: Caio Ariede (http://caioariede.com)
    // improved by: Kevin van Zonneveld (http://kvz.io)
    // improved by: Caio Ariede (http://caioariede.com)
    // improved by: A. Matías Quezada (http://amatiasq.com)
    // improved by: preuter
    // improved by: Brett Zamir (http://brett-zamir.me)
    // improved by: Mirko Faber
    //    input by: David
    // bugfixed by: Wagner B. Soares
    // bugfixed by: Artur Tchernychev
    // bugfixed by: Stephan Bösch-Plepelits (http://github.com/plepe)
    //      note 1: Examples all have a fixed timestamp to prevent
    //      note 1: tests to fail because of variable time(zones)
    //   example 1: strtotime('+1 day', 1129633200)
    //   returns 1: 1129719600
    //   example 2: strtotime('+1 week 2 days 4 hours 2 seconds', 1129633200)
    //   returns 2: 1130425202
    //   example 3: strtotime('last month', 1129633200)
    //   returns 3: 1127041200
    //   example 4: strtotime('2009-05-04 08:30:00 GMT')
    //   returns 4: 1241425800
    //   example 5: strtotime('2009-05-04 08:30:00+00')
    //   returns 5: 1241425800
    //   example 6: strtotime('2009-05-04 08:30:00+02:00')
    //   returns 6: 1241418600
    //   example 7: strtotime('2009-05-04T08:30:00Z')
    //   returns 7: 1241425800

    var parsed;
    var match;
    var today;
    var year;
    var date;
    var days;
    var ranges;
    var len;
    var times;
    var regex;
    var i;
    var fail = false;

    if (!text) {
      return fail;
    }

    // Unecessary spaces
    text = text.replace(/^\s+|\s+$/g, '').replace(/\s{2,}/g, ' ').replace(/[\t\r\n]/g, '').toLowerCase();

    // in contrast to php, js Date.parse function interprets:
    // dates given as yyyy-mm-dd as in timezone: UTC,
    // dates with "." or "-" as MDY instead of DMY
    // dates with two-digit years differently
    // etc...etc...
    // ...therefore we manually parse lots of common date formats
    var pattern = new RegExp(['^(\\d{1,4})', '([\\-\\.\\/:])', '(\\d{1,2})', '([\\-\\.\\/:])', '(\\d{1,4})', '(?:\\s(\\d{1,2}):(\\d{2})?:?(\\d{2})?)?', '(?:\\s([A-Z]+)?)?$'].join(''));
    match = text.match(pattern);

    if (match && match[2] === match[4]) {
      if (match[1] > 1901) {
        switch (match[2]) {
          case '-':
            // YYYY-M-D
            if (match[3] > 12 || match[5] > 31) {
              return fail;
            }

            return new Date(match[1], parseInt(match[3], 10) - 1, match[5], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
          case '.':
            // YYYY.M.D is not parsed by strtotime()
            return fail;
          case '/':
            // YYYY/M/D
            if (match[3] > 12 || match[5] > 31) {
              return fail;
            }

            return new Date(match[1], parseInt(match[3], 10) - 1, match[5], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
        }
      } else if (match[5] > 1901) {
        switch (match[2]) {
          case '-':
            // D-M-YYYY
            if (match[3] > 12 || match[1] > 31) {
              return fail;
            }

            return new Date(match[5], parseInt(match[3], 10) - 1, match[1], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
          case '.':
            // D.M.YYYY
            if (match[3] > 12 || match[1] > 31) {
              return fail;
            }

            return new Date(match[5], parseInt(match[3], 10) - 1, match[1], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
          case '/':
            // M/D/YYYY
            if (match[1] > 12 || match[3] > 31) {
              return fail;
            }

            return new Date(match[5], parseInt(match[1], 10) - 1, match[3], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
        }
      } else {
        switch (match[2]) {
          case '-':
            // YY-M-D
            if (match[3] > 12 || match[5] > 31 || match[1] < 70 && match[1] > 38) {
              return fail;
            }

            year = match[1] >= 0 && match[1] <= 38 ? +match[1] + 2000 : match[1];
            return new Date(year, parseInt(match[3], 10) - 1, match[5], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
          case '.':
            // D.M.YY or H.MM.SS
            if (match[5] >= 70) {
              // D.M.YY
              if (match[3] > 12 || match[1] > 31) {
                return fail;
              }

              return new Date(match[5], parseInt(match[3], 10) - 1, match[1], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
            }
            if (match[5] < 60 && !match[6]) {
              // H.MM.SS
              if (match[1] > 23 || match[3] > 59) {
                return fail;
              }

              today = new Date();
              return new Date(today.getFullYear(), today.getMonth(), today.getDate(), match[1] || 0, match[3] || 0, match[5] || 0, match[9] || 0) / 1000;
            }

            // invalid format, cannot be parsed
            return fail;
          case '/':
            // M/D/YY
            if (match[1] > 12 || match[3] > 31 || match[5] < 70 && match[5] > 38) {
              return fail;
            }

            year = match[5] >= 0 && match[5] <= 38 ? +match[5] + 2000 : match[5];
            return new Date(year, parseInt(match[1], 10) - 1, match[3], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
          case ':':
            // HH:MM:SS
            if (match[1] > 23 || match[3] > 59 || match[5] > 59) {
              return fail;
            }

            today = new Date();
            return new Date(today.getFullYear(), today.getMonth(), today.getDate(), match[1] || 0, match[3] || 0, match[5] || 0) / 1000;
        }
      }
    }

    // other formats and "now" should be parsed by Date.parse()
    if (text === 'now') {
      return now === null || isNaN(now) ? new Date().getTime() / 1000 | 0 : now | 0;
    }
    if (!isNaN(parsed = Date.parse(text))) {
      return parsed / 1000 | 0;
    }
    // Browsers !== Chrome have problems parsing ISO 8601 date strings, as they do
    // not accept lower case characters, space, or shortened time zones.
    // Therefore, fix these problems and try again.
    // Examples:
    //   2015-04-15 20:33:59+02
    //   2015-04-15 20:33:59z
    //   2015-04-15t20:33:59+02:00
    pattern = new RegExp(['^([0-9]{4}-[0-9]{2}-[0-9]{2})', '[ t]', '([0-9]{2}:[0-9]{2}:[0-9]{2}(\\.[0-9]+)?)', '([\\+-][0-9]{2}(:[0-9]{2})?|z)'].join(''));
    match = text.match(pattern);
    if (match) {
      // @todo: time zone information
      if (match[4] === 'z') {
        match[4] = 'Z';
      } else if (match[4].match(/^([+-][0-9]{2})$/)) {
        match[4] = match[4] + ':00';
      }

      if (!isNaN(parsed = Date.parse(match[1] + 'T' + match[2] + match[4]))) {
        return parsed / 1000 | 0;
      }
    }

    date = now ? new Date(now * 1000) : new Date();
    days = {
      'sun': 0,
      'mon': 1,
      'tue': 2,
      'wed': 3,
      'thu': 4,
      'fri': 5,
      'sat': 6
    };
    ranges = {
      'yea': 'FullYear',
      'mon': 'Month',
      'day': 'Date',
      'hou': 'Hours',
      'min': 'Minutes',
      'sec': 'Seconds'
    };

    function lastNext(type, range, modifier) {
      var diff;
      var day = days[range];

      if (typeof day !== 'undefined') {
        diff = day - date.getDay();

        if (diff === 0) {
          diff = 7 * modifier;
        } else if (diff > 0 && type === 'last') {
          diff -= 7;
        } else if (diff < 0 && type === 'next') {
          diff += 7;
        }

        date.setDate(date.getDate() + diff);
      }
    }

    function process(val) {
      // @todo: Reconcile this with regex using \s, taking into account
      // browser issues with split and regexes
      var splt = val.split(' ');
      var type = splt[0];
      var range = splt[1].substring(0, 3);
      var typeIsNumber = /\d+/.test(type);
      var ago = splt[2] === 'ago';
      var num = (type === 'last' ? -1 : 1) * (ago ? -1 : 1);

      if (typeIsNumber) {
        num *= parseInt(type, 10);
      }

      if (ranges.hasOwnProperty(range) && !splt[1].match(/^mon(day|\.)?$/i)) {
        return date['set' + ranges[range]](date['get' + ranges[range]]() + num);
      }

      if (range === 'wee') {
        return date.setDate(date.getDate() + num * 7);
      }

      if (type === 'next' || type === 'last') {
        lastNext(type, range, num);
      } else if (!typeIsNumber) {
        return false;
      }

      return true;
    }

    times = '(years?|months?|weeks?|days?|hours?|minutes?|min|seconds?|sec' + '|sunday|sun\\.?|monday|mon\\.?|tuesday|tue\\.?|wednesday|wed\\.?' + '|thursday|thu\\.?|friday|fri\\.?|saturday|sat\\.?)';
    regex = '([+-]?\\d+\\s' + times + '|' + '(last|next)\\s' + times + ')(\\sago)?';

    match = text.match(new RegExp(regex, 'gi'));
    if (!match) {
      return fail;
    }

    for (i = 0, len = match.length; i < len; i++) {
      if (!process(match[i])) {
        return fail;
      }
    }

    return date.getTime() / 1000;
  }
});

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
  function _t() {
    return new RegExp(/(.*?)\.?([^.]*?)\.?(com|net|org|biz|ws|in|me|co\.uk|co|org\.uk|ltd\.uk|plc\.uk|me\.uk|edu|mil|br\.com|cn\.com|eu\.com|hu\.com|no\.com|qc\.com|sa\.com|se\.com|se\.net|us\.com|uy\.com|ac|co\.ac|gv\.ac|or\.ac|ac\.ac|af|am|as|at|ac\.at|co\.at|gv\.at|or\.at|asn\.au|com\.au|edu\.au|org\.au|net\.au|id\.au|be|ac\.be|adm\.br|adv\.br|am\.br|arq\.br|art\.br|bio\.br|cng\.br|cnt\.br|com\.br|ecn\.br|eng\.br|esp\.br|etc\.br|eti\.br|fm\.br|fot\.br|fst\.br|g12\.br|gov\.br|ind\.br|inf\.br|jor\.br|lel\.br|med\.br|mil\.br|net\.br|nom\.br|ntr\.br|odo\.br|org\.br|ppg\.br|pro\.br|psc\.br|psi\.br|rec\.br|slg\.br|tmp\.br|tur\.br|tv\.br|vet\.br|zlg\.br|br|ab\.ca|bc\.ca|mb\.ca|nb\.ca|nf\.ca|ns\.ca|nt\.ca|on\.ca|pe\.ca|qc\.ca|sk\.ca|yk\.ca|ca|cc|ac\.cn|com\.cn|edu\.cn|gov\.cn|org\.cn|bj\.cn|sh\.cn|tj\.cn|cq\.cn|he\.cn|nm\.cn|ln\.cn|jl\.cn|hl\.cn|js\.cn|zj\.cn|ah\.cn|gd\.cn|gx\.cn|hi\.cn|sc\.cn|gz\.cn|yn\.cn|xz\.cn|sn\.cn|gs\.cn|qh\.cn|nx\.cn|xj\.cn|tw\.cn|hk\.cn|mo\.cn|cn|cx|cz|de|dk|fo|com\.ec|tm\.fr|com\.fr|asso\.fr|presse\.fr|fr|gf|gs|co\.il|net\.il|ac\.il|k12\.il|gov\.il|muni\.il|ac\.in|co\.in|org\.in|ernet\.in|gov\.in|net\.in|res\.in|is|it|ac\.jp|co\.jp|go\.jp|or\.jp|ne\.jp|ac\.kr|co\.kr|go\.kr|ne\.kr|nm\.kr|or\.kr|li|lt|lu|asso\.mc|tm\.mc|com\.mm|org\.mm|net\.mm|edu\.mm|gov\.mm|ms|nl|no|nu|pl|ro|org\.ro|store\.ro|tm\.ro|firm\.ro|www\.ro|arts\.ro|rec\.ro|info\.ro|nom\.ro|nt\.ro|se|si|com\.sg|org\.sg|net\.sg|gov\.sg|sk|st|tf|ac\.th|co\.th|go\.th|mi\.th|net\.th|or\.th|tm|to|com\.tr|edu\.tr|gov\.tr|k12\.tr|net\.tr|org\.tr|com\.tw|org\.tw|net\.tw|ac\.uk|uk\.com|uk\.net|gb\.com|gb\.net|vg|sh|kz|ch|info|ua|gov|name|pro|ie|hk|com\.hk|org\.hk|net\.hk|edu\.hk|us|tk|cd|by|ad|lv|eu\.lv|bz|es|jp|cl|ag|mobi|eu|co\.nz|org\.nz|net\.nz|maori\.nz|iwi\.nz|io|la|md|sc|sg|vc|tw|travel|my|se|tv|pt|com\.pt|edu\.pt|asia|fi|com\.ve|net\.ve|fi|org\.ve|web\.ve|info\.ve|co\.ve|tel|im|gr|ru|net\.ru|org\.ru|hr|com\.hr|ly|xyz|so)$/);
  }

  function _d(s) {
    return decodeURIComponent(s.replace(/\+/g, ' '));
  }

  function _i(arg, str) {
    var sptr = arg.charAt(0);
    var split = str.split(sptr);

    if (sptr === arg) {
      return split;
    }

    arg = parseInt(arg.substring(1), 10);

    return split[arg < 0 ? split.length + arg : arg - 1];
  }

  function _f(arg, str) {
    var sptr = arg.charAt(0);
    var split = str.split('&');
    var field = [];
    var params = {};
    var tmp = [];
    var arg2 = arg.substring(1);

    for (var i = 0, ii = split.length; i < ii; i++) {
      field = split[i].match(/(.*?)=(.*)/);

      // TODO: regex should be able to handle this.
      if (!field) {
        field = [split[i], split[i], ''];
      }

      if (field[1].replace(/\s/g, '') !== '') {
        field[2] = _d(field[2] || '');

        // If we have a match just return it right away.
        if (arg2 === field[1]) {
          return field[2];
        }

        // Check for array pattern.
        tmp = field[1].match(/(.*)\[([0-9]+)]/);

        if (tmp) {
          params[tmp[1]] = params[tmp[1]] || [];

          params[tmp[1]][tmp[2]] = field[2];
        } else {
          params[field[1]] = field[2];
        }
      }
    }

    if (sptr === arg) {
      return params;
    }

    return params[arg2];
  }

  return function (arg, url) {
    var _l = {};
    var tmp;

    if (arg === 'tld?') {
      return _t();
    }

    url = url || (typeof window !== 'undefined' && window.location || '').toString();

    if (!arg) {
      return url;
    }

    arg = arg.toString();

    if (tmp = url.match(/^mailto:([^/].+)/)) {
      _l.protocol = 'mailto';
      _l.email = tmp[1];
    } else {
      // Ignore Hashbangs.
      if (tmp = url.match(/(.*?)\/#!(.*)/)) {
        url = tmp[1] + tmp[2];
      }

      // Hash.
      if (tmp = url.match(/(.*?)#(.*)/)) {
        _l.hash = tmp[2];
        url = tmp[1];
      }

      // Return hash parts.
      if (_l.hash && arg.match(/^#/)) {
        return _f(arg, _l.hash);
      }

      // Query
      if (tmp = url.match(/(.*?)\?(.*)/)) {
        _l.query = tmp[2];
        url = tmp[1];
      }

      // Return query parts.
      if (_l.query && arg.match(/^\?/)) {
        return _f(arg, _l.query);
      }

      // Protocol.
      if (tmp = url.match(/(.*?):?\/\/(.*)/)) {
        _l.protocol = tmp[1].toLowerCase();
        url = tmp[2];
      }

      // Path.
      if (tmp = url.match(/(.*?)(\/.*)/)) {
        _l.path = tmp[2];
        url = tmp[1];
      }

      // Clean up path.
      _l.path = (_l.path || '').replace(/^([^/])/, '/$1').replace(/\/$/, '');

      // Return path parts.
      if (arg.match(/^[-0-9]+$/)) {
        arg = arg.replace(/^([^/])/, '/$1');
      }
      if (arg.match(/^\//)) {
        return _i(arg, _l.path.substring(1));
      }

      // File.
      tmp = _i('/-1', _l.path.substring(1));

      if (tmp && (tmp = tmp.match(/(.*?)\.(.*)/))) {
        _l.file = tmp[0];
        _l.filename = tmp[1];
        _l.fileext = tmp[2];
      }

      // Port.
      if (tmp = url.match(/(.*):([0-9]+)$/)) {
        _l.port = tmp[2];
        url = tmp[1];
      }

      // Auth.
      if (tmp = url.match(/(.*?)@(.*)/)) {
        _l.auth = tmp[1];
        url = tmp[2];
      }

      // User and pass.
      if (_l.auth) {
        tmp = _l.auth.match(/(.*):(.*)/);

        _l.user = tmp ? tmp[1] : _l.auth;
        _l.pass = tmp ? tmp[2] : undefined;
      }

      // Hostname.
      _l.hostname = url.toLowerCase();

      // Return hostname parts.
      if (arg.charAt(0) === '.') {
        return _i(arg, _l.hostname);
      }

      // Domain, tld and sub domain.
      if (_t()) {
        tmp = _l.hostname.match(_t());

        if (tmp) {
          _l.tld = tmp[3];
          _l.domain = tmp[2] ? tmp[2] + '.' + tmp[3] : undefined;
          _l.sub = tmp[1] || undefined;
        }
      }

      // Set port and protocol defaults if not set.
      _l.port = _l.port || (_l.protocol === 'https' ? '443' : '80');
      _l.protocol = _l.protocol || (_l.port === '443' ? 'https' : 'http');
    }

    // Return arg.
    if (arg in _l) {
      return _l[arg];
    }

    // Return everything.
    if (arg === '{}') {
      return _l;
    }

    // Default to undefined for no match.
    return undefined;
  };
}();

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(0));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(0));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Hex;

}));

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(0), __webpack_require__(15), __webpack_require__(13));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha256", "./hmac"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	return CryptoJS.HmacSHA256;

}));

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(0));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(0));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(0));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));

/***/ }),
/* 16 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ })
/******/ ]);
//# sourceMappingURL=api.js.map